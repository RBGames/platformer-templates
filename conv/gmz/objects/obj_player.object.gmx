<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>-9</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Variables

// General
intHSpeed = 0;
intVSpeed = 0;
intMove = 0; 
intMultiplier = 2.0;

// Collision
bolGround = scr_ground();
intColLeft = place_meeting(x - 1, y, obj_block);
intColRight = place_meeting(x + 1, y, obj_block);
bolAir = !place_meeting(x, y, obj_block);
justPlatform = bolGround &amp;&amp; !place_meeting(x, y + 1, obj_block);
bolSurface = scr_water();

// Instance collision
insMovingHPlatform = instance_place(x, y + 1, obj_platformH);
insMovingVPlatform = instance_place(x, y + 3, obj_platformV);
insFallingPlatform = instance_place(x, y + 1, obj_platformF);
currentFallingPlatform = noone; 

// Land Movement
intMaxHSpeed = 7 * intMultiplier;
intMaxVSpeed = 10 * intMultiplier;
intJumpHeight = 12 * intMultiplier;
intGravityNorm = 0.5 * intMultiplier;
intGravitySlide = 0.15 * intMultiplier;
intGroundAcc = 1.0 * intMultiplier;
intGroundFric = 1.2 * intMultiplier;
intAirAcc = 0.75 * intMultiplier;
intAirFric = 0.09 * intMultiplier;

// Water Movement
intMaxHSpeedWater = 2.5 * intMultiplier;
intMaxVSpeedWater = 4.0 * intMultiplier;
intJumpHeightW = 8 * intMultiplier;
intGravityNormW = 0.2 * intMultiplier;
intGroundAccW = 0.6 * intMultiplier;
intGroundFricW = 2.1 * intMultiplier;
intWaterAcc = 0.40 * intMultiplier;
intWaterFric = 0.2 * intMultiplier;

// Jumping
bolTempJump = false;
wallJumpEnabled = true;
bolRightWallJump = true;
bolLeftWallJump = true;
intDJump = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Disable the player temporal jumping
bolTempJump = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Variables that need to change

/// Keyboard variables
keyleft = -keyboard_check(vk_left);
keyright = keyboard_check(vk_right);
keyjump = keyboard_check_pressed(ord("X")); //keyboard_check(ord("X"));
keyjumprelease = keyboard_check_released(ord("X"));
keydown = keyboard_check(vk_down);
keyjumppressed = keyboard_check_pressed(ord("X"));
KeyAction = keyboard_check(ord("Z"));

// Collision
bolGround = scr_ground();
intColLeft = place_meeting(x - 1, y, obj_block);
intColRight = place_meeting(x + 1, y, obj_block);
bolAir = !place_meeting(x, y, obj_block);
justPlatform = bolGround &amp;&amp; !place_meeting(x, y + 1, obj_block);
bolSurface = scr_water();

// Instance collision
insMovingHPlatform = instance_place(x, y + 1, obj_platformH);
insMovingVPlatform = instance_place(x, y + 3, obj_platformV);
insFallingPlatform = instance_place(x, y + 1, obj_platformF);
currentFallingPlatform = noone; 

// Don't allow more than one Temporal Jumping
if (intVSpeed &lt; 0 ){
   bolTempJump = false;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Behavior

/// Acceleration and Friction

// On land
if (!bolSurface) {
  if (!bolGround) {
    intTempAcc = intAirAcc;
    intTempFric = intAirFric;
  } else {
    intTempAcc = intGroundAcc;
    intTempFric = intGroundFric;
  }
}

// Inside water
else {
  if (!bolGround) {
    intTempAcc = intWaterAcc;
    intTempFric = intWaterFric;
  } else {
    intTempAcc = intGroundAccW;
    intTempFric = intGroundFricW;
  }
}

/// Horizontal Speed

intMove = keyleft + keyright;
if (!bolSurface) {
  if (intMove != 0) {
    intHSpeed = scr_approach(intHSpeed, intMaxHSpeed * intMove, intTempAcc);
  } else {
    intHSpeed = scr_approach(intHSpeed, intMaxHSpeed * intMove, intTempFric);
  }
} else {
    if (intMove != 0) {
      intHSpeed = scr_approach(intHSpeed, intMaxHSpeedWater * intMove, intTempAcc);
    } else {
      intHSpeed = scr_approach(intHSpeed, intMaxHSpeedWater * intMove, intTempFric);
    }
}

// Speed over the horizontal moving platform
if (
  instance_place(x, y + 1, obj_platformH) &amp;&amp;
  !instance_place(x, y, obj_platformH) &amp;&amp;
  bolAir &amp;&amp;
  justPlatform &amp;&amp;
  !intColLeft &amp;&amp;
  !intColRight
) {
  x += insMovingHPlatform.intHSpeed;
}

/// Vertical speed

// Ground
if (!bolSurface) {
  if (!bolGround) {
    if ((intColLeft || intColRight) &amp;&amp; intVSpeed &gt;= 0) {
      intVSpeed = scr_approach(intVSpeed, intMaxVSpeed, intGravitySlide); // Free fall while touching a wall
    } else {
      intVSpeed = scr_approach(intVSpeed, intMaxVSpeed, intGravityNorm); // Free fall
    }
  } else {
    if (intDJump == 0) {
      intDJump++;
    }
  }
}

// Water
else {
  if (!bolGround) {
    if ((intColLeft || intColRight) &amp;&amp; intVSpeed &gt;= 0) {
      intVSpeed = scr_approach(intVSpeed, intMaxVSpeed, intGravitySlide); // Free fall while touching a wall
    }
    intVSpeed = scr_approach(intVSpeed, intMaxVSpeedWater, intGravityNormW); // Free fall
  } else {
    if (intDJump == 0) {
      intDJump++;
    }
  }
}

// Falling down of a platform

if (justPlatform) {
  if (keydown &amp;&amp; place_meeting(x, y + 1, obj_platform)) {
    y++;
  }

  if (keydown &amp;&amp; place_meeting(x, y + 1, obj_platformH)) {
    y++;
  }

  if (keydown &amp;&amp; place_meeting(x, y + 1, obj_platformV)) {
    y += 2;
  }
}

/// Jumping

  // Re-Enabling the Double Jump
if (bolGround) {
  intDJump = 1;
}
  
  // On land
if (!bolSurface) {
  // Single Jump
  if ( (keyjump) &amp;&amp; ((bolGround) || (bolTempJump)) ) {
    intVSpeed = -intMaxVSpeed;
    bolTempJump = false;
  }
  // Double Jump
  if ( (keyjump) &amp;&amp;  (intDJump &gt; 0) &amp;&amp; (!bolGround)){
    intVSpeed = -intMaxVSpeed * 0.6;
    bolTempJump = false;
    intDJump--;
  }
  
  // On water
} else {
  if (keyjump) intVSpeed = -intMaxVSpeedWater;
}
// Variable Jumping
if (keyjumprelease) {
  if (intVSpeed &lt; 0) {
    if (insMovingVPlatform == noone) intVSpeed = 0.5;
  }
}

/// Wall Jump
if (!bolSurface &amp;&amp; wallJumpEnabled) {
  // Left Wall
  if (intColLeft &amp;&amp; !bolGround &amp;&amp; (keyjumppressed) &amp;&amp; bolLeftWallJump) {
    if (intMove &lt; 0) {
      intHSpeed = intMaxHSpeed * 0.5;
      intVSpeed = -intJumpHeight * 1.1;
    } else {
      intHSpeed = intMaxHSpeed;
      intVSpeed = -intJumpHeight * 0.6;
    }
    bolLeftWallJump = false;
    bolRightWallJump = true;
  }

  // Right Wall
  if (intColRight &amp;&amp; !bolGround &amp;&amp; keyjumppressed &amp;&amp; bolRightWallJump) {
    if (intMove &gt; 0) {
      intHSpeed = -intMaxHSpeed * 0.5;
      intVSpeed = -intJumpHeight * 1.1;
    } else {
      intHSpeed = -intMaxHSpeed;
      intVSpeed = -intJumpHeight * 0.6;
    }
    bolRightWallJump = false;
    bolLeftWallJump = true;
  }
}

 // Resetting wall jumps on landing
if(bolGround) {
  bolRightWallJump = true;
  bolLeftWallJump = true;
}

// Horizontal Collision
repeat(abs(intHSpeed)) {
  // Slope up
  if (
    place_meeting(x + sign(intHSpeed), y, obj_block) &amp;&amp;
    !place_meeting(x + sign(intHSpeed), y - 1, obj_block)
  ) {
    y--;
  }
  // Slope down
  if (
    !place_meeting(x + sign(intHSpeed), y, obj_block) &amp;&amp;
    !place_meeting(x + sign(intHSpeed), y + 1, obj_block) &amp;&amp;
    place_meeting(x + sign(intHSpeed), y + 2, obj_block)
  ) {
    y++;
  }
  if (!place_meeting(x + sign(intHSpeed), y, obj_block)) {
    x += sign(intHSpeed);
  } else {
    intHSpeed = 0;
    break;
  }
  
}

// Vertical Collision
repeat(abs(intVSpeed)) {

  if (place_meeting(x, y + sign(intVSpeed), obj_block)) {
    intVSpeed = 0;
    break;
  }

  /// Platforms collision

  // one-way platform
  else if (
    place_meeting(x, y + sign(intVSpeed), obj_platform) &amp;&amp;
    !place_meeting(x, y, obj_platform) &amp;&amp;
    intVSpeed &gt;= 0
  ) {
    intVSpeed = 0;
    break;
  }

  // Horizontal moving platform
  else if (
    place_meeting(x, y + sign(intVSpeed), obj_platformH) &amp;&amp;
    !place_meeting(x, y, obj_platformH) &amp;&amp;
    intVSpeed &gt;= 0
  ) {
    intVSpeed = 0;
    break;
  }

  // Vertical moving platform
  else if (
    place_meeting(x, y + sign(intVSpeed) + 1, obj_platformV) &amp;&amp;
    !place_meeting(x, y, obj_platformV) &amp;&amp;
    intVSpeed &gt;= 0
  ) {
    
    intVSpeed = instance_place(x, y + sign(intVSpeed) + 1, obj_platformV)
      .intVSpeed;
      
    break;
  }
  
  // Falling Platform
  else if (
    place_meeting(x, y + sign(intVSpeed), obj_platformF) &amp;&amp;
    !place_meeting(x, y, obj_platformF) &amp;&amp;
    intVSpeed &gt;= 0
  ) {
    intVSpeed = 0;
    break;
  }
  
   // No Platform
    else {
   y += sign(intVSpeed);   
  }
  
}

// Falling platform fall apart

if (
  intVSpeed == 0 &amp;&amp;
  insFallingPlatform != noone &amp;&amp;
  !instance_place(x, y, obj_platformF)
)
  currentFallingPlatform = insFallingPlatform;
{
  with (currentFallingPlatform) {
    if (!bolFalling &amp;&amp; (obj_player.y = y)) {
      bolFalling = true;
      alarm[0] = intTimer;
    }
  }
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Interact with the room's borders (the sprite must be centered at x)

// Right Border
if (x &lt;= 0 + sprite_width / 2) {
  intMove = 0;
  intHSpeed = 0;
  x = 0 + sprite_width / 2;
}

// Right Border
if (x &gt;= room_width - sprite_width / 2) {
  intMove = 0;
  intHSpeed = 0;
  x = room_width - sprite_width / 2;
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animation

if (intColLeft &amp;&amp; bolLeftWallJump) &amp;&amp; (!bolSurface) {
  sprite_index = spr_player_wall;
  image_xscale = 1;
  image_speed = 0.3 * room_speed;
}

if (intColRight &amp;&amp; bolRightWallJump) &amp;&amp; (!bolSurface) {
  sprite_index = spr_player_wall;
  image_xscale = -1;
  image_speed = 0.3 * room_speed;
}

if (bolTempJump) {
  sprite_index = spr_player_temp_jump;
  image_xscale = 1;
  image_speed = 1 * room_speed;
}

if (bolGround) || (!intColLeft &amp;&amp; !intColRight &amp;&amp; !bolTempJump) || (bolSurface){
  sprite_index = spr_player;
  image_xscale = 1;
  image_speed = 1 * room_speed;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// More debugging
draw_text(32, 32, "FPS: " + string(fps));
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Debugging
draw_set_color(c_black);
draw_set_font(fnt_roboto32);
draw_self();
//draw_text(x, y - 128, string(intHSpeed) + "  " + string(intVSpeed));
//draw_text(x, y - 200, justPlatform);
draw_text(x, y - 200, "On Ground: " + string(bolGround));
draw_text(x, y - 240, "On Water: " + string(bolSurface));
//draw_text(x, y - 280, "Jump Key: " + string(keyjump));
//draw_text(x, y - 320, "Temp Jumping: " + string(bolTempJump));
draw_text(x, y - 280, "Y: " + string(y));
draw_text(x, y - 320, "Platfom Y: " + string(instance_nearest(x,y,obj_platformV).y));
draw_text(x, y - 360, "DJump Count: " + string(intDJump));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
