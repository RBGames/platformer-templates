<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>-9</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// variables
image_speed = 0.5;
Puntuacion = 0
push = false
// movimiento terrestre
intVX       = 0;
intVY       = 0;
intMove     = 0;
intVXTrhow  = 0;
intVYTrhow  = 0;
intMultiplier =        1.0;
intVYMax               = 9              *intMultiplier;
intVXMax               = 6.5            *intMultiplier;
intJumpHeight          = 8              *intMultiplier;
intGravityNorm         = 0.5            *intMultiplier;
intGravitySlide        = 0.15           *intMultiplier;
intGroundAcc           = 1.0            *intMultiplier;
intGroundFric          = 1.3            *intMultiplier;
intAirAcc              = 0.75           *intMultiplier;
intAirFric             = 0.1            *intMultiplier;

intColLt = (place_meeting(x-1,y,obj_block))
intColRight = (place_meeting(x+1,y,obj_block))
bolAir = (!place_meeting(x,y,obj_block))

//Movimiento acuatico
intVYMaxW             = 8.0            *intMultiplier;
intVXMaxW             = 2.5            *intMultiplier;
intJumpHeightW        = 10             *intMultiplier;
intGravityNormW       = 0.2            *intMultiplier;
intGroundAccW         = 0.6            *intMultiplier;
intGroundFricW        = 2.1            *intMultiplier;
intWaterAcc           = 0.45           *intMultiplier;
intWaterFric          = 0.2            *intMultiplier; 

bolBounce = false
bolGround = scr_suelo()
// Salto
intDjump = 1
keylt = -keyboard_check(vk_left);
keyright = keyboard_check(vk_right);
keyjump = keyboard_check(ord("X"));
keyjumprelease = keyboard_check_released(ord("X"));
keydown = keyboard_check(vk_down)
keyjumppressed = keyboard_check_pressed(ord ("X"));
KeyAction = keyboard_check(ord("Z"))
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Desplazamiento
//var keyleft, keyright, keyjump, keyjumprelease,keyjumppressed, keydown;
  
keyleft = -keyboard_check(vk_left);
keyright = keyboard_check(vk_right);
keyjump = keyboard_check(ord("X"));
keyjumprelease = keyboard_check_released(ord("X"));
keydown = keyboard_check(vk_down)
keyjumppressed = keyboard_check_pressed(ord ("X"));
KeyAction = keyboard_check(ord("Z"))
// Comprobacion de colisiones
intColLeft = place_meeting(x-1, y, obj_block)
intColRight = place_meeting(x+1, y, obj_block) 

bolGround = scr_suelo()
bolSurface = scr_agua()
if (bolGround) bolEffect = true
/*intMovilH =(instance_place(x,y+1,obj_movilH))
intMovilV = (instance_place(x,y+3,obj_movilV))
intMovilF = (instance_place(x,y+1,obj_movilF))*/
intMove = keyleft + keyright;
// definir aceleracion y friccion en funcion del medio
 if (!bolSurface)
 { if (!bolGround) 
 
  {
   intTempAcc = intAirAcc
   intTempFric = intAirFric
 }
 else
 { 
    intTempAcc = intGroundAcc
    intTempFric = intGroundFric
 }
 }
 
 
 else   // dentro del agua
 {
   
   if (!bolGround)
    {
   intTempAcc   = intWaterAcc
   intTempFric  = intWaterFric
 }
 
  else  
 {
    intTempAcc = intGroundAccW
    intTempFric = intGroundFricW
 
 }
  }
 
// Velocidad Horizontal

if (!bolSurface)
{
  if (!bolBounce)
   {
     if (intMove !=0) intVX = scr_approach(intVX, intVXMax * intMove,intTempAcc)
  else intVX = scr_approach(intVX,intVXMax * intMove,intTempFric)
}
 }
 
 else
 {
 
    if (!bolBounce)
    if (intMove !=0) intVX = scr_approach(intVX, intVXMaxW * intMove,intTempAcc)
    else intVX = scr_approach(intVX,intVXMaxW * intMove,intTempFric)

 }


// Velocidad Sobre La Plataforma DE movimiento horizontal
/*if (instance_place(x,y+1,obj_movilH)) and (!instance_place(x,y,obj_movilH)) and (bolAir)  x += intMovilH.intVX
//if !bolGround  x += intMovilH.intVX
{}
*/


//Velocidad vertical
if (!bolSurface)
{
if(!bolGround)
{
   if ((intColLeft or intColRight) and intVY &gt;= 0) intVY = scr_approach(intVY,intVYMax,intGravitySlide) // Caida Mientras Estamos Pegados A La Pared 
  else intVY = scr_approach(intVY,intVYMax,intGravityNorm) // caida libre
}
else
    if (intDjump == 0)
    {
      intDjump ++
    }
}

else  // Agua


if(!bolGround)
{
   if ((intColLeft or intColRight) and intVY &gt;= 0) intVY = scr_approach(intVY,intVYMax,intGravitySlide) // Caida Mientras Estamos Pegados A La Pared bajo el agua
   intVY = scr_approach(intVY,intVYMaxW,intGravityNormW) // caida libre en el agua
}
else
    if (intDjump == 0)
    {
      intDjump ++
    }





// Caida Desde Una Plataforma
if (keydown) and (place_meeting(x,y + 1,obj_platform)) y++
else if (keydown) and (place_meeting(x,y + 1,obj_movilV)) y += 2
else if (keydown) and (place_meeting(x,y + 1,obj_movilH)) y ++
///Salto
 if (!bolSurface)
 {
if (keyjump and bolGround) 
{
intVY = -intVYMax


}
}
  else
  {
   if (keyjump and bolGround) intVY = -intVYMaxW
  
  }
// Salto Variado
if (keyjumprelease)
{
  //if (intVY &lt; 0) intVY *= 0.5
  if (intVY &lt; 0)
  {
   // if (intMovilV == noone) intVY = 0.5
   intVY=0;
  
  }
}

// Doble Salto
/*
if (keyjump and !bolGround and (intDjump &gt;0))
{
  if (!intColLeft and !intColRight)
    {
    
      intVY = intVYMax * 0.75
      intDjump --
    
    }

}
  
  
  // Nado
  
else

if (keyjump and !bolGround and (intDjump &gt;0))
{
  if (!intColLeft and !intColRight)
    {
    
      intVY = intVYMaxW * 0.75
      
    
    }

}
 */
  
// Salto De Pared
if (!bolSurface)
{
if (intColLeft and ord("X")  and !bolGround and keyjumppressed)
{  if (intMove &lt; 0)
{
  intVX = intVXMax * 0.5
  intVY = -intJumpHeight * 1.25
}
else
 { intVX = intVXMax
  intVY = -intJumpHeight * 0.75
  }}
  
  //Derecha
  if (intColRight and ord("X")  and !bolGround and keyjumppressed)
{ if (intMove &gt; 0)
{
   intVX = -intVXMax *0.5
   intVY = -intJumpHeight *1.25
}
else
 {
   intVX = -intVXMax
   intVY = -intJumpHeight *0.75
 }}
 }
//Colision Horizontal
repeat (abs(intVX))
{
 // Cuesta Arriba
  if (place_meeting(x + sign(intVX),y,obj_block)) and (!place_meeting(x + sign(intVX),y - 1,obj_block)) y--
  //Cuesta Abajo
  if (!place_meeting(x + sign(intVX),y,obj_block)) and (!place_meeting(x+sign(intVX),y +1,obj_block)) and (place_meeting( x + sign(intVX),y + 2,obj_block)) y++

  if (!place_meeting(x+ sign(intVX),y,obj_block))
  
 { x+= sign(intVX)
 }
 else
 {
   intVX =0;
   break;
 
 }

}
// Colision Vertical
repeat(abs(intVY))
{
 
  if (place_meeting(x, y + sign(intVY),obj_block))
  
 { intVY = 0
   break;
   
   }
      ///  plataforma unidireccional
 else if (place_meeting(x,y + sign (intVY),obj_platform) and !place_meeting(x,y,obj_platform)) and (intVY &gt;=0)
 {
   intVY = 0;
   break;
 
 }
 
   //plataforma de movimiento horizontal
  else if (place_meeting(x,y + sign (intVY),obj_movilH) and !place_meeting(x,y,obj_movilH)) and (intVY &gt;=0)
 {
   intVY = 0;
   break;
 
 }
     /// plataforma de movimiento vertical 
  else if (place_meeting(x,y + sign (intVY) +1,obj_movilV) and !place_meeting(x,y,obj_movilV)) and (intVY &gt;=0)
 {
   intVY = instance_place(x,y +sign(intVY) +1,obj_movilV).intVY;
   break;
  }
      /// plataforma que se cae
   else if (place_meeting(x,y + sign (intVY),obj_movilF) and !place_meeting(x,y,obj_movilF)) and (intVY &gt;=0)
 {
   intVY = 0;
   break;
 
 }
  
 
  else y += sign(intVY)
}


// Derribo de plataforma que se cae

if (intVY= 0) and (instance_place(x,y+1,obj_movilF) != noone) and (!instance_place(x,y,obj_movilF))

{

with (obj_movilF)

{

if (!bolFalling)and (obj_player.y = y)

{
 
    bolFalling = true
    alarm[0] = intTimer
      }
   }

}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="82">
      <action>
        <libid>1</libid>
        <id>331</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_restart_game</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
